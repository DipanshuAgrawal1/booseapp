@page
@model mainweb.Pages.IndexModel
@{
    ViewData["Title"] = "Canvas Drawing App";
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@ViewData["Title"]</title>

    <style>
        /* General body and layout styles */
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Menu bar style */
        .menu-bar {
            display: flex;
            justify-content: center;
            background-color: #333;
            padding: 10px;
            width: 100%;
        }

            /* Button styles in the menu */
            .menu-bar button {
                background-color: #444;
                color: white;
                border: none;
                padding: 10px 20px;
                margin: 5px;
                cursor: pointer;
                font-size: 16px;
            }

                /* Button hover effect */
                .menu-bar button:hover {
                    background-color: #666;
                }

        /* Canvas container style */
        .canvas-container {
            margin-top: 20px;
            position: relative;
        }

        /* Canvas style */
        #myCanvas {
            border: 2px solid #000;
            background-color: #fff;
        }

        /* Output window style */
        .output-window {
            width: 100%;
            height: 200px;
            margin-top: 20px;
            background-color: #eee;
            padding: 10px;
            overflow-y: auto;
        }

        /* Output text style */
        #outputText {
            white-space: pre-wrap;
        }

        /* Input area container style */
        .input-container {
            width: 80%;
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Textarea style for program input */
        #programText {
            width: 100%;
            height: 100px;
            font-family: monospace;
            padding: 10px;
            border: 1px solid #ccc;
            margin-bottom: 10px;
        }

        /* Button container style */
        .button-container {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <!-- Menu bar with buttons for various actions -->
    <div class="menu-bar">
        <button onclick="saveImage()">Save Image</button>
        <button onclick="loadImage()">Load Image</button>
        <button onclick="togglePen()">Pen</button>
        <button onclick="toggleCircle()">Circle</button>
        <button onclick="toggleEraser()">Eraser</button>
        <button onclick="toggleSound()">Sound</button>
        <button onclick="resetCanvas()">Reset</button>
    </div>

    <!-- Canvas area for drawing -->
    <div class="canvas-container">
        <canvas id="myCanvas" width="800" height="600"></canvas>
    </div>

    <!-- Program input and run button -->
    <div class="input-container">
        <textarea id="programText" placeholder="Enter your drawing commands here..."></textarea>
        <div class="button-container">
            <button onclick="runProgram()">Run</button>
        </div>
    </div>

    <!-- Output window to display messages and errors -->
    <div class="output-window">
        <h3>Error/Output</h3>
        <pre id="outputText"></pre>
    </div>

    <!-- File input for loading images -->
    <input type="file" id="fileInput" onchange="loadImageFromFile(event)" style="display:none;" />

    <script>
        let isDrawing = false;
        let isCircleMode = false;
        let lastPoint = { x: 0, y: 0 };
        let currentCircle = null;
        let canvas = document.getElementById('myCanvas');
        let ctx = canvas.getContext('2d');
        let outputText = document.getElementById('outputText');

        /// <summary>
        /// Function to update the output area with messages.
        /// </summary>
        function updateOutput(message) {
            outputText.textContent += message + "\n";
        }

        /// <summary>
        /// Event listener for mouse down to start drawing or creating a circle.
        /// </summary>
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                if (isCircleMode) {
                    currentCircle = { startX: e.offsetX, startY: e.offsetY, width: 0, height: 0 };
                } else {
                    isDrawing = true;
                    lastPoint = { x: e.offsetX, y: e.offsetY };
                }
            }
        });

        /// <summary>
        /// Event listener for mouse move to draw lines or circles.
        /// </summary>
        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing && !isCircleMode) {
                ctx.beginPath();
                ctx.moveTo(lastPoint.x, lastPoint.y);
                ctx.lineTo(e.offsetX, e.offsetY);
                ctx.stroke();
                lastPoint = { x: e.offsetX, y: e.offsetY };
            } else if (isCircleMode && currentCircle) {
                currentCircle.width = e.offsetX - currentCircle.startX;
                currentCircle.height = e.offsetY - currentCircle.startY;
                redrawCanvas();
                ctx.beginPath();
                ctx.arc(currentCircle.startX, currentCircle.startY, Math.sqrt(Math.pow(currentCircle.width, 2) + Math.pow(currentCircle.height, 2)), 0, 2 * Math.PI);
                ctx.stroke();
            }
        });

        /// <summary>
        /// Event listener for mouse up to finish drawing or circle.
        /// </summary>
        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            if (isCircleMode && currentCircle) {
                redrawCanvas();
                ctx.beginPath();
                ctx.arc(currentCircle.startX, currentCircle.startY, Math.sqrt(Math.pow(currentCircle.width, 2) + Math.pow(currentCircle.height, 2)), 0, 2 * Math.PI);
                ctx.stroke();
                currentCircle = null;
            }
        });

        /// <summary>
        /// Toggles Pen mode for freehand drawing.
        /// </summary>
        function togglePen() {
            isCircleMode = false;
            updateOutput("Pen mode enabled");
        }

        /// <summary>
        /// Toggles Circle mode for drawing circles.
        /// </summary>
        function toggleCircle() {
            isCircleMode = true;
            updateOutput("Circle mode enabled");
        }

        /// <summary>
        /// Toggles Eraser mode for erasing parts of the canvas.
        /// </summary>
        function toggleEraser() {
            isCircleMode = false;
            updateOutput("Eraser mode enabled");
        }

        /// <summary>
        /// Resets the canvas, clearing all content.
        /// </summary>
        function resetCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updateOutput("Canvas reset");
        }

        /// <summary>
        /// Saves the canvas content as an image.
        /// </summary>
        function saveImage() {
            let dataUrl = canvas.toDataURL('image/png');
            let link = document.createElement('a');
            link.href = dataUrl;
            link.download = 'canvas_image.png';
            link.click();
            updateOutput("Image saved");
        }

        /// <summary>
        /// Triggers the load image file input dialog.
        /// </summary>
        function loadImage() {
            document.getElementById('fileInput').click(); // Trigger file input click
        }

        /// <summary>
        /// Loads an image into the canvas from the file input.
        /// </summary>
        function loadImageFromFile(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas before drawing the image
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    }
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
                updateOutput("Image loaded");
            }
        }

        /// <summary>
        /// Placeholder for toggling sound (not implemented).
        /// </summary>
        function toggleSound() {
            updateOutput("Sound functionality is not implemented in this example");
        }

        /// <summary>
        /// Parses and runs the drawing commands entered by the user.
        /// </summary>
        function runProgram() {
            let programText = document.getElementById('programText').value;
            updateOutput("Running program:\n" + programText);

            let commands = programText.split("\n");

            commands.forEach((command) => {
                command = command.trim();
                if (command.startsWith("drawto")) {
                    parseDrawTo(command);
                } else if (command.startsWith("circle")) {
                    parseCircle(command);
                } else {
                    updateOutput(`Unrecognized command: ${command}`);
                }
            });

            updateOutput("Program execution completed.");
        }

        /// <summary>
        /// Parses a "drawto" command and draws a line to the specified coordinates.
        /// </summary>
        function parseDrawTo(command) {
            const regex = /^drawto\s+(\d+),\s*(\d+)$/;
            const match = command.match(regex);

            if (match) {
                const x = parseInt(match[1]);
                const y = parseInt(match[2]);

                // Draw line to the specified coordinates
                ctx.beginPath();
                ctx.moveTo(lastPoint.x, lastPoint.y);
                ctx.lineTo(x, y);
                ctx.stroke();
                lastPoint = { x: x, y: y };

                updateOutput(`Drawing line to (${x}, ${y})`);
            } else {
                updateOutput("Invalid drawto command format. Use: drawto x,y");
            }
        }

        /// <summary>
        /// Parses a "circle" command and draws a circle at the center of the canvas.
        /// </summary>
        function parseCircle(command) {
            const regex = /^circle\s+(\d+)$/;
            const match = command.match(regex);

            if (match) {
                const radius = parseInt(match[1]);
                const centerX = canvas.width / 2;  // Center X of canvas
                const centerY = canvas.height / 2;  // Center Y of canvas

                // Draw a circle at the center of the canvas
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();

                updateOutput(`Drawing circle at center (${centerX}, ${centerY}) with radius ${radius}`);
            } else {
                updateOutput("Invalid circle command format. Use: circle radius");
            }
        }

        /// <summary>
        /// Redraws the canvas after clearing it.
        /// </summary>
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Redraw any existing drawings or shapes
        }
    </script>
</body>
</html>
